import { useState, useEffect, useCallback, useRef } from 'react';
import {
  GameState,
  createInitialGameState,
  spawnNewPiece,
  isCollision,
  placePiece,
  clearLines,
  calculateScore,
  calculateLevel,
  isGameOver,
  hardDrop,
  BOARD_WIDTH,
  BOARD_HEIGHT,
  TetrominoType,
} from '@/lib/tetris';

export function useTetris() {
  const [gameState, setGameState] = useState<GameState | null>(null);
  const [dropTime, setDropTime] = useState<number>(1000);
  const gameLoopRef = useRef<NodeJS.Timeout | null>(null);
  const dropTimeRef = useRef<NodeJS.Timeout | null>(null);

  // ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ÏóêÏÑúÎßå Ï¥àÍ∏∞ ÏÉÅÌÉú ÏÑ§Ï†ï
  useEffect(() => {
    console.log('üéÆ Initializing game state');
    setGameState(createInitialGameState());
    console.log('‚úÖ Game state initialized');
  }, []);

  // Í≤åÏûÑ ÏÜçÎèÑ Í≥ÑÏÇ∞
  const getDropTime = useCallback((level: number) => {
    const dropTime = Math.max(100, 1000 - (level - 1) * 100);
    console.log('‚è±Ô∏è Drop time for level', level, ':', dropTime, 'ms');
    return dropTime;
  }, []);

  // Í≤åÏûÑ ÏãúÏûë
  const startGame = useCallback(() => {
    console.log('üöÄ Starting new game');
    setGameState(createInitialGameState());
    setDropTime(getDropTime(1));
    console.log('‚úÖ New game started');
  }, [getDropTime]);

  // Í≤åÏûÑ ÏùºÏãúÏ†ïÏßÄ/Ïû¨Í∞ú
  const togglePause = useCallback(() => {
    setGameState(prev => prev ? { ...prev, paused: !prev.paused } : null);
  }, []);

  // ÏÉàÎ°úÏö¥ Ï°∞Í∞Å ÏÉùÏÑ±
  const spawnPiece = useCallback(() => {
    setGameState(prev => {
      if (!prev) return null;
      
      // ÌòÑÏû¨ nextPieceÎ•º currentPieceÎ°ú ÏÇ¨Ïö©
      const newPiece = {
        type: prev.nextPiece,
        position: { x: Math.floor(BOARD_WIDTH / 2) - 1, y: 0 },
        rotation: 0,
      };
      
      return {
        ...prev,
        currentPiece: newPiece,
        nextPiece: getRandomTetromino(),
      };
    });
  }, []);

  // Ï°∞Í∞Å Ïù¥Îèô
  const movePiece = useCallback((dx: number, dy: number) => {
    setGameState(prev => {
      if (!prev || prev.gameOver || prev.paused || !prev.currentPiece) return prev;

      const newPosition = {
        x: prev.currentPiece.position.x + dx,
        y: prev.currentPiece.position.y + dy,
      };

      if (!isCollision(prev.board, { ...prev.currentPiece, position: newPosition })) {
        return {
          ...prev,
          currentPiece: { ...prev.currentPiece, position: newPosition },
        };
      }

      // Ï∂©ÎèåÏù¥ Î∞úÏÉùÌïòÍ≥† ÏïÑÎûòÎ°ú Ïù¥ÎèôÌïòÎ†§Í≥† ÌñàÏùÑ Îïå
      if (dy > 0) {
        const newBoard = placePiece(prev.board, prev.currentPiece);
        const { newBoard: clearedBoard, linesCleared } = clearLines(newBoard);
        const newLines = prev.lines + linesCleared;
        const newLevel = calculateLevel(newLines);
        const scoreIncrease = calculateScore(linesCleared, prev.level);

        // Í≤åÏûÑ Ïò§Î≤Ñ Í≤ÄÏÇ¨
        if (isGameOver(clearedBoard)) {
          return { ...prev, gameOver: true };
        }

        return {
          ...prev,
          board: clearedBoard,
          currentPiece: null,
          lines: newLines,
          level: newLevel,
          score: prev.score + scoreIncrease,
        };
      }

      return prev;
    });
  }, []);

  // Ï°∞Í∞Å ÌöåÏ†Ñ
  const rotatePiece = useCallback(() => {
    setGameState(prev => {
      if (!prev || prev.gameOver || prev.paused || !prev.currentPiece) return prev;

      const newRotation = (prev.currentPiece.rotation + 1) % 4;
      const rotatedPiece = { ...prev.currentPiece, rotation: newRotation };

      if (!isCollision(prev.board, rotatedPiece)) {
        return {
          ...prev,
          currentPiece: rotatedPiece,
        };
      }

      // Î≤Ω ÌÇ• (wall kick) ÏãúÎèÑ
      const kicks = [
        { x: -1, y: 0 },
        { x: 1, y: 0 },
        { x: 0, y: -1 },
        { x: -1, y: -1 },
        { x: 1, y: -1 },
      ];

      for (const kick of kicks) {
        const kickedPosition = {
          x: prev.currentPiece.position.x + kick.x,
          y: prev.currentPiece.position.y + kick.y,
        };

        if (!isCollision(prev.board, { ...rotatedPiece, position: kickedPosition })) {
          return {
            ...prev,
            currentPiece: { ...rotatedPiece, position: kickedPosition },
          };
        }
      }

      return prev;
    });
  }, []);

  // ÌïòÎìú ÎìúÎ°≠
  const hardDropPiece = useCallback(() => {
    setGameState(prev => {
      if (!prev || prev.gameOver || prev.paused || !prev.currentPiece) return prev;
      const { position, linesCleared } = hardDrop(prev.board, prev.currentPiece);
      const newBoard = placePiece(prev.board, { ...prev.currentPiece, position });
      const { newBoard: clearedBoard } = clearLines(newBoard);
      const newLines = prev.lines + linesCleared;
      const newLevel = calculateLevel(newLines);
      const scoreIncrease = calculateScore(linesCleared, prev.level);

      if (isGameOver(clearedBoard)) {
        return { ...prev, gameOver: true };
      }

      return {
        ...prev,
        board: clearedBoard,
        currentPiece: null,
        lines: newLines,
        level: newLevel,
        score: prev.score + scoreIncrease,
      };
    });
  }, []);

  // ÏûêÎèô ÌïòÍ∞ï
  const dropPiece = useCallback(() => {
    setGameState(prev => {
      if (!prev || prev.gameOver || prev.paused || !prev.currentPiece) return prev;
      return movePieceInState(prev, 0, 1);
    });
  }, []);

  // ÌÇ§Î≥¥Îìú Ïù¥Î≤§Ìä∏ Ï≤òÎ¶¨
  const handleKeyPress = useCallback((event: KeyboardEvent) => {
    console.log('üîç Key pressed:', event.code, 'Key:', event.key);
    
    if (typeof window === 'undefined') {
      console.log('‚ùå Window is undefined, returning early');
      return;
    }
    
    // Í≤åÏûÑ ÏÉÅÌÉú Ï≤¥ÌÅ¨
    setGameState(prev => {
      if (!prev) {
        console.log('‚ùå Game state is null');
        return prev;
      }
      
      if (prev.gameOver) {
        console.log('‚ùå Game is over');
        return prev;
      }
      
      if (prev.paused) {
        console.log('‚ùå Game is paused');
        return prev;
      }

      console.log('‚úÖ Processing key:', event.code);
      
      // Ïù¥Î≤§Ìä∏ Ï≤òÎ¶¨
      switch (event.code) {
        case 'ArrowLeft':
          console.log('‚¨ÖÔ∏è Moving left');
          event.preventDefault();
          break;
        case 'ArrowRight':
          console.log('‚û°Ô∏è Moving right');
          event.preventDefault();
          break;
        case 'ArrowDown':
          console.log('‚¨áÔ∏è Moving down');
          event.preventDefault();
          break;
        case 'ArrowUp':
          console.log('‚¨ÜÔ∏è Rotating');
          event.preventDefault();
          break;
        case 'Space':
          console.log('‚¨áÔ∏è Hard drop');
          event.preventDefault();
          break;
        case 'KeyP':
          console.log('‚è∏Ô∏è Toggle pause');
          event.preventDefault();
          break;
        default:
          console.log('‚ùì Unknown key:', event.code);
      }
      
      return prev;
    });
    
    // setGameState Ïô∏Î∂ÄÏóêÏÑú Ïã§Ï†ú Ïï°ÏÖò Ïã§Ìñâ
    setTimeout(() => {
      setGameState(currentState => {
        if (!currentState || currentState.gameOver || currentState.paused) {
          return currentState;
        }
        
        switch (event.code) {
          case 'ArrowLeft':
            return movePieceInState(currentState, -1, 0);
          case 'ArrowRight':
            return movePieceInState(currentState, 1, 0);
          case 'ArrowDown':
            return movePieceInState(currentState, 0, 1);
          case 'ArrowUp':
            return rotatePieceInState(currentState);
          case 'Space':
            return hardDropInState(currentState);
          case 'KeyP':
            return { ...currentState, paused: !currentState.paused };
          default:
            return currentState;
        }
      });
    }, 0);
  }, []);

  // ÏÉÅÌÉú ÎÇ¥ÏóêÏÑú Ï°∞Í∞Å Ïù¥Îèô Ìï®Ïàò
  const movePieceInState = (state: GameState, dx: number, dy: number): GameState => {
    if (!state.currentPiece) return state;

    const newPosition = {
      x: state.currentPiece.position.x + dx,
      y: state.currentPiece.position.y + dy,
    };

    if (!isCollision(state.board, { ...state.currentPiece, position: newPosition })) {
      return {
        ...state,
        currentPiece: { ...state.currentPiece, position: newPosition },
      };
    }

    // Ï∂©ÎèåÏù¥ Î∞úÏÉùÌïòÍ≥† ÏïÑÎûòÎ°ú Ïù¥ÎèôÌïòÎ†§Í≥† ÌñàÏùÑ Îïå
    if (dy > 0) {
      const newBoard = placePiece(state.board, state.currentPiece);
      const { newBoard: clearedBoard, linesCleared } = clearLines(newBoard);
      const newLines = state.lines + linesCleared;
      const newLevel = calculateLevel(newLines);
      const scoreIncrease = calculateScore(linesCleared, state.level);

      // Í≤åÏûÑ Ïò§Î≤Ñ Í≤ÄÏÇ¨
      if (isGameOver(clearedBoard)) {
        return { ...state, gameOver: true };
      }

      return {
        ...state,
        board: clearedBoard,
        currentPiece: null,
        lines: newLines,
        level: newLevel,
        score: state.score + scoreIncrease,
      };
    }

    return state;
  };

  // ÏÉÅÌÉú ÎÇ¥ÏóêÏÑú Ï°∞Í∞Å ÌöåÏ†Ñ Ìï®Ïàò
  const rotatePieceInState = (state: GameState): GameState => {
    if (!state.currentPiece) return state;

    const newRotation = (state.currentPiece.rotation + 1) % 4;
    const rotatedPiece = { ...state.currentPiece, rotation: newRotation };

    if (!isCollision(state.board, rotatedPiece)) {
      return {
        ...state,
        currentPiece: rotatedPiece,
      };
    }

    // Î≤Ω ÌÇ• (wall kick) ÏãúÎèÑ
    const kicks = [
      { x: -1, y: 0 },
      { x: 1, y: 0 },
      { x: 0, y: -1 },
      { x: -1, y: -1 },
      { x: 1, y: -1 },
    ];

    for (const kick of kicks) {
      const kickedPosition = {
        x: state.currentPiece.position.x + kick.x,
        y: state.currentPiece.position.y + kick.y,
      };

      if (!isCollision(state.board, { ...rotatedPiece, position: kickedPosition })) {
        return {
          ...state,
          currentPiece: { ...rotatedPiece, position: kickedPosition },
        };
      }
    }

    return state;
  };

  // ÏÉÅÌÉú ÎÇ¥ÏóêÏÑú ÌïòÎìú ÎìúÎ°≠ Ìï®Ïàò
  const hardDropInState = (state: GameState): GameState => {
    if (!state.currentPiece) return state;

    const { position, linesCleared } = hardDrop(state.board, state.currentPiece);
    const newBoard = placePiece(state.board, { ...state.currentPiece, position });
    const { newBoard: clearedBoard } = clearLines(newBoard);
    const newLines = state.lines + linesCleared;
    const newLevel = calculateLevel(newLines);
    const scoreIncrease = calculateScore(linesCleared, state.level);

    if (isGameOver(clearedBoard)) {
      return { ...state, gameOver: true };
    }

    return {
      ...state,
      board: clearedBoard,
      currentPiece: null,
      lines: newLines,
      level: newLevel,
      score: state.score + scoreIncrease,
    };
  };

  // Í≤åÏûÑ Î£®ÌîÑ
  useEffect(() => {
    if (!gameState || gameState.gameOver || gameState.paused) {
      if (dropTimeRef.current) {
        clearInterval(dropTimeRef.current);
        dropTimeRef.current = null;
      }
      return;
    }

    // ÏÉàÎ°úÏö¥ Ï°∞Í∞ÅÏù¥ ÌïÑÏöîÌïòÎ©¥ ÏÉùÏÑ±
    if (!gameState.currentPiece) {
      spawnPiece();
    }

    // ÏûêÎèô ÌïòÍ∞ï ÏÑ§Ï†ï
    dropTimeRef.current = setInterval(() => {
      dropPiece();
    }, dropTime);

    return () => {
      if (dropTimeRef.current) {
        clearInterval(dropTimeRef.current);
      }
    };
  }, [gameState, dropTime, spawnPiece, dropPiece]);

  // Î†àÎ≤®Ïóê Îî∞Î•∏ ÏÜçÎèÑ Ï°∞Ï†ï
  useEffect(() => {
    if (gameState) {
      setDropTime(getDropTime(gameState.level));
    }
  }, [gameState, getDropTime]);

  // ÌÇ§Î≥¥Îìú Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà
  useEffect(() => {
    console.log('üéØ Setting up keyboard event listener');
    
    if (typeof window !== 'undefined') {
      console.log('‚úÖ Window is available, adding event listener');
      window.addEventListener('keydown', handleKeyPress);
      
      // ÌÖåÏä§Ìä∏Ïö© Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà Ï∂îÍ∞Ä
      const testHandler = (e: KeyboardEvent) => {
        console.log('üß™ Test event listener triggered:', e.code);
      };
      window.addEventListener('keydown', testHandler);
      
      return () => {
        console.log('üßπ Cleaning up keyboard event listeners');
        window.removeEventListener('keydown', handleKeyPress);
        window.removeEventListener('keydown', testHandler);
      };
    } else {
      console.log('‚ùå Window is not available');
    }
  }, [handleKeyPress]);

  return {
    gameState,
    startGame,
    togglePause,
  };
}

// ÎûúÎç§ ÌÖåÌä∏Î°úÎØ∏ÎÖ∏ ÏÉùÏÑ± Ìï®Ïàò (ÌÉÄÏûÖ Ïò§Î•ò Ìï¥Í≤∞Ïö©)
function getRandomTetromino(): TetrominoType {
  const types: TetrominoType[] = ['I', 'O', 'T', 'S', 'Z', 'J', 'L'];
  return types[Math.floor(Math.random() * types.length)];
}
